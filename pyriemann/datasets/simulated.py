import numpy as np
from sklearn.utils.validation import check_random_state
from .sampling import generate_random_spd_matrix, sample_gaussian_spd
from pyriemann.utils.distance import distance_riemann
from pyriemann.utils.base import powm, sqrtm


def make_gaussian_blobs(n_samples=100, n_dim=2, class_sep=1.0, class_disp=1.0,
                        random_state=None):
    """Generate SPD dataset with two classes sampled from Riemannian Gaussian

    Generate a dataset with SPD matrices generated from two Riemannian
    Gaussian distributions. The distributions have the same class dispersions
    and the distance between their centers of mass is an input parameter.

    Parameters
    ----------
    n_samples : int (default: 100)
        How many samples to generate for each class.
    n_dim : int (default: 2)
        Dimensionality of the SPD matrices generated by the distributions.
    class_sep : float (default: 1.0)
        Parameter controlling the separability of the classes.
    class_disp : float (default: 1.0)
        Intra dispersion of the points sampled from each class.
    random_state : int, RandomState instance or None (default: None)
        Pass an int for reproducible output across multiple function calls.

    Returns
    -------
    X : ndarray, shape (2*n_samples, n_dim, n_dim)
        ndarray of SPD matrices.
    y : ndarray, shape (n_samples,)
        labels corresponding to each sample.

    Notes
    -----
    .. versionadded:: 0.2.8

    """

    rs = check_random_state(random_state)

    # generate dataset for class 0
    CO = generate_random_spd_matrix(n_dim)
    X0 = sample_gaussian_spd(n_samples=n_samples,
                             mean=CO,
                             sigma=class_disp,
                             random_state=random_state)
    y0 = np.zeros(n_samples)

    # generate dataset for class 1
    epsilon = np.exp(class_sep/np.sqrt(n_dim))
    C1 = epsilon * CO
    X1 = sample_gaussian_spd(n_samples=n_samples,
                             mean=C1,
                             sigma=class_disp,
                             random_state=random_state)
    y1 = np.ones(n_samples)

    X = np.concatenate([X0, X1])
    y = np.concatenate([y0, y1])
    idx = rs.permutation(len(X))
    X = X[idx]
    y = y[idx]

    return X, y


def make_outliers(n_samples, mean, sigma, outlier_coeff=10, random_state=None):
    """Generate a set of outlier points

    Simulate data points that are outliers for a given Riemannian Gaussian
    distribution with fixed mean and dispersion.

    Parameters
    ----------
    n_samples : int
        How many samples to generate.
    mean : ndarray, shape (n_dim, n_dim)
        Center of the Riemannian Gaussian distribution.
    sigma : float
        Dispersion of the Riemannian Gaussian distribution.
    outlier_coeff: float
        Coefficient determining how to define an outlier data point, i.e. how
        many times the sigma parameter its distance to the mean should be.
    random_state : int, RandomState instance or None (default: None)
        Pass an int for reproducible output across multiple function calls.

    Returns
    -------
    outliers : ndarray, shape (n_samples, n_dim, n_dim)
        Array of simulated outlier data points

    Notes
    -----
    .. versionadded:: 0.2.8
    """

    n_dim = mean.shape[1]
    mean_sqrt = sqrtm(mean)

    outliers = np.zeros((n_samples, n_dim, n_dim))
    for i in range(n_samples):
        Oi = generate_random_spd_matrix(n_dim=n_dim, random_state=random_state)
        epsilon_num = outlier_coeff * sigma * n_dim
        epsilon_den = distance_riemann(Oi, np.eye(n_dim))**2
        epsilon = np.sqrt(epsilon_num / epsilon_den)
        outliers[i, :, :] = mean_sqrt @ powm(Oi, epsilon) @ mean_sqrt

    return outliers
